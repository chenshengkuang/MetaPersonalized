
vcols <- rev(c("#440154FF", "#440256FF", "#450457FF", "#450559FF", "#46075AFF",
           "#46085CFF", "#460A5DFF", "#460B5EFF", "#470D60FF", "#470E61FF",
           "#471063FF", "#471164FF", "#471366FF", "#481567FF", "#481668FF",
           "#481769FF", "#48196BFF", "#481B6DFF", "#481B6DFF", "#481C6EFF",
           "#481E70FF", "#482070FF", "#482072FF", "#482274FF", "#482475FF",
           "#482576FF", "#482677FF", "#482778FF", "#482979FF", "#472A7AFF",
           "#472B7AFF", "#472D7BFF", "#472E7CFF", "#472F7DFF", "#46307EFF",
           "#46327EFF", "#46337FFF", "#463480FF", "#453581FF", "#453781FF",
           "#453882FF", "#443983FF", "#443A83FF", "#443B84FF", "#433D84FF",
           "#433E85FF", "#423F85FF", "#424086FF", "#424186FF", "#414287FF",
           "#414487FF", "#404588FF", "#404688FF", "#3F4788FF", "#3F4889FF",
           "#3E4989FF", "#3E4B89FF", "#3E4C8AFF", "#3D4D8AFF", "#3D4E8AFF",
           "#3C4F8AFF", "#3C508BFF", "#3B518BFF", "#3A538BFF", "#3A548CFF",
           "#39558CFF", "#39558CFF", "#38578CFF", "#38598CFF", "#375A8CFF",
           "#375B8DFF", "#365C8DFF", "#365D8DFF", "#355E8DFF", "#355F8DFF",
           "#34608DFF", "#34618DFF", "#33628DFF", "#33638DFF", "#32648EFF",
           "#32658EFF", "#31668EFF", "#31678EFF", "#31688EFF", "#30698EFF",
           "#306A8EFF", "#2F6B8EFF", "#2F6C8EFF", "#2E6D8EFF", "#2E6E8EFF",
           "#2E6F8EFF", "#2D708EFF", "#2D718EFF", "#2C718EFF", "#2C728EFF",
           "#2C738EFF", "#2B748EFF", "#2B758EFF", "#2A768EFF", "#2A778EFF",
           "#2A788EFF", "#29798EFF", "#297A8EFF", "#287B8EFF", "#287D8EFF",
           "#287E8EFF", "#277F8EFF", "#27808EFF", "#26818EFF", "#26828EFF",
           "#26828EFF", "#25838EFF", "#25848EFF", "#25858EFF", "#24868EFF",
           "#24878EFF", "#23888EFF", "#23898EFF", "#238A8DFF", "#228B8DFF",
           "#228C8DFF", "#228D8DFF", "#218E8DFF", "#218F8DFF", "#21908DFF",
           "#21918CFF", "#20928CFF", "#20928CFF", "#20938CFF", "#1F948CFF",
           "#1F958BFF", "#1F968BFF", "#1F978BFF", "#1F988BFF", "#1F998AFF",
           "#1F9A8AFF", "#1E9B8AFF", "#1E9C89FF", "#1E9D89FF", "#1F9E89FF",
           "#1F9F88FF", "#1FA088FF", "#1FA188FF", "#1FA187FF", "#20A287FF",
           "#20A386FF", "#21A586FF", "#21A685FF", "#22A785FF", "#22A885FF",
           "#23A983FF", "#24AA83FF", "#25AB82FF", "#25AC82FF", "#26AD81FF",
           "#27AD81FF", "#28AE80FF", "#29AF7FFF", "#2AB07FFF", "#2CB17EFF",
           "#2DB27DFF", "#2EB37CFF", "#2FB47CFF", "#31B57BFF", "#32B67AFF",
           "#34B679FF", "#35B779FF", "#37B878FF", "#38B977FF", "#3ABA76FF",
           "#3BBB75FF", "#3DBC74FF", "#3FBC73FF", "#40BD72FF", "#42BE71FF",
           "#44BF70FF", "#46C06FFF", "#49C16EFF", "#4BC16DFF", "#4DC26CFF",
           "#4FC36BFF", "#51C46AFF", "#53C569FF", "#55C568FF", "#57C666FF",
           "#59C864FF", "#5BC864FF", "#5DC863FF", "#5FCA61FF", "#62CB5FFF",
           "#64CB5FFF", "#66CB5DFF", "#68CD5BFF", "#6BCD5AFF", "#6DCE59FF",
           "#6FCF57FF", "#72D056FF", "#75D054FF", "#76D153FF", "#79D151FF",
           "#7CD250FF", "#7FD34EFF", "#81D34DFF", "#84D44BFF", "#86D549FF",
           "#89D548FF", "#8BD646FF", "#8ED645FF", "#90D743FF", "#93D741FF",
           "#95D840FF", "#98D83EFF", "#9BD93CFF", "#9DD93BFF", "#A0DA39FF",
           "#A2DA37FF", "#A6DB36FF", "#A8DB34FF", "#ABDC31FF", "#AEDC30FF",
           "#B1DD2EFF", "#B3DD2CFF", "#B6DE2AFF", "#B9DE29FF", "#BBDE27FF",
           "#BEDF26FF", "#C1DF24FF", "#C3DF22FF", "#C7E020FF", "#C9E020FF",
           "#CCE11EFF", "#CFE11CFF", "#D1E21BFF", "#D4E21AFF", "#D7E219FF",
           "#D9E319FF", "#DCE318FF", "#DEE318FF", "#E1E418FF", "#E4E419FF",
           "#E7E419FF", "#E9E51AFF", "#ECE51BFF", "#EFE51CFF", "#F1E51DFF",
           "#F4E61EFF", "#F6E620FF", "#F8E621FF", "#FBE723FF", "#FDE725FF"))



#' @title Interaction Plot for an "mp" Class Object.
#'
#' @description This function plots interaction between received treatment and recommended treatment,
#' which provides an estimate of treatment effect of the identified subgroup.
#'
#' @details In the interaction plot, each point is the group mean given a received treatment
#' and a recommended treatment. Although usually
#' overestimating treatment effect in training set, interaction plots provides a sanity check for treatment
#' recommendation rules. Given a specific index of penalty parameter, the function
#' plots corresponding interaction plots.
#'
#' @param mp A fitted "mp" class object returned by \code{mpersonalzied} function
#' @param penalty_index The index of penalty parameter configuration in \code{mp$penalty_parameter_sequence}.
#' When \code{mp$penalty = "none"}, \code{penalty_index} is automatically set to be 1.
#'
#' @import ggplot2 gridExtra
#' @return A list object with each element as the interaction plots for a penalty parameter configuration.
#'
#' @examples
#' set.seed(123)
#' sim_dat  = simulated_dataset(n = 200, problem = "meta-analysis")
#' Xlist = sim_dat$Xlist; Ylist = sim_dat$Ylist; Trtlist = sim_dat$Trtlist
#'
#' # fit different rules with SGL penalty for this meta-analysis problem
#' mp_mod_diff = mpersonalized(problem = "meta-analysis",
#'                             Xlist = Xlist, Ylist = Ylist, Trtlist = Trtlist,
#'                             penalty = "lasso", single_rule = FALSE)
#'
#' # interaction plot of the 5th penalty parameter
#' plots = plot(mp = mp_mod_diff, penalty_index = 5)
#' set.seed(NULL)
#' @export
plot.mp = function(mp, penalty_index){

  Ylist = mp$Ylist
  Trtlist = mp$Trtlist
  Plist = mp$Plist
  single_rule = mp$single_rule
  q = mp$number_studies_or_outcomes
  penalty = mp$penalty
  problem = mp$problem


  if (penalty == "none"){

    pred = predict(mp)$opt_treatment[[1]]

  } else {

    if (missing(penalty_index))
      stop("For penalty not equal to 'none', penalty_index must be inputed!")

    pred = predict(mp)$opt_treatment[[penalty_index]]

  }


  #group 1 defined as receive 1 and recommend 1; group 2 as receive 0 and recommend 1
  #group 3 defined as receive 0 and recommend 0; group 4 as receive 1 and recommend 0
  meanlist = mapply(function(Trt, pred, Y,  P) c(sum(Y * as.numeric(Trt == 1 & pred == 1) / P) / sum(as.numeric(Trt == 1 & pred == 1) / P),
                                                 sum(Y * as.numeric(Trt == 0 & pred == 1) / (1 - P)) / sum(as.numeric(Trt == 0 & pred == 1) / (1 - P)),
                                                 sum(Y * as.numeric(Trt == 0 & pred == 0) / (1 - P)) / sum(as.numeric(Trt == 0 & pred == 0) / (1 - P)),
                                                 sum(Y * as.numeric(Trt == 1 & pred == 0) / P) / sum(as.numeric(Trt == 1 & pred == 1) / P)),
                    Trt = Trtlist, pred = pred, Y = Ylist, P = Plist, SIMPLIFY = FALSE)

  plotlist = replicate(q, list())
  for (i in 1:q){
    plot_dat = data.frame(mean = meanlist[[i]], recommend = as.factor(c(1, 1, 0, 0)),
                          received = as.factor(c(1, 0, 0, 1)))
    plotlist[[i]] = ggplot(data = plot_dat, aes(y = mean, x = recommend, group = received)) +
      geom_line(aes(color = received), size = 2, alpha = 0.4) + geom_point(size = 3, aes(color = received))

    if (problem == "meta-analysis")
      plotlist[[i]] = plotlist[[i]] + ggtitle(label = paste("Study ",i))

    if (problem == "multiple outcomes")
      plotlist[[i]] = plotlist[[i]] + ggtitle(label = paste("Outcome ",i))
  }

  return(plotlist)
}


#' @title Interaction Plot for an "mp_cv" Class Object.
#'
#' @description This function plots interaction between received treatment and recommended treatment,
#' given the optimal penalty parameter.
#'
#' @param mp_cv A fitted 'mp_cv' class object returned by \code{mpersonalzied_cv} function
#'
#' @import ggplot2 gridExtra
#' @return A list object representing the interaction plots for the optimal penalty parameter configuration.
#' Specifically, \eqn{k}th element is the interaction plot for the \eqn{k}th study/outcome.
#'
#' @examples
#' set.seed(123)
#' sim_dat  = simulated_dataset(n = 200, problem = "meta-analysis")
#' Xlist = sim_dat$Xlist; Ylist = sim_dat$Ylist; Trtlist = sim_dat$Trtlist
#'
#' # fit different rules with lasso penalty for this meta-analysis problem
#' mp_cvmod_diff = mpersonalized_cv(problem = "meta-analysis",
#'                                  Xlist = Xlist, Ylist = Ylist, Trtlist = Trtlist,
#'                                  penalty = "lasso", single_rule = FALSE)
#'
#' plots = plot(mp_cv = mp_cvmod_diff)
#' set.seed(NULL)
#' @export
plot.mp_cv = function(mp_cv){

  Ylist = mp_cv$Ylist
  Trtlist = mp_cv$Trtlist
  Plist = mp_cv$Plist
  q = mp_cv$number_studies_or_outcomes
  problem = mp_cv$problem

  pred = predict(mp_cv)$opt_treatment

  #group 1 defined as receive 1 and recommend 1; group 2 as receive 0 and recommend 1
  #group 3 defined as receive 0 and recommend 0; group 4 as receive 1 and recommend 0
  meanlist = mapply(function(Trt, pred, Y,  P) c(sum(Y * as.numeric(Trt == 1 & pred == 1) / P) / sum(as.numeric(Trt == 1 & pred == 1) / P),
                                                 sum(Y * as.numeric(Trt == 0 & pred == 1) / (1 - P)) / sum(as.numeric(Trt == 0 & pred == 1) / (1 - P)),
                                                 sum(Y * as.numeric(Trt == 0 & pred == 0) / (1 - P)) / sum(as.numeric(Trt == 0 & pred == 0) / (1 - P)),
                                                 sum(Y * as.numeric(Trt == 1 & pred == 0) / P) / sum(as.numeric(Trt == 1 & pred == 1) / P)),
                    Trt = Trtlist, pred = pred, Y = Ylist, P = Plist, SIMPLIFY = FALSE)

  plotlist = replicate(q, list())
  for (i in 1:q){
    plot_dat = data.frame(mean = meanlist[[i]], recommend = as.factor(c(1, 1, 0, 0)),
                          received = as.factor(c(1, 0, 0, 1)))
    plotlist[[i]] = ggplot(data = plot_dat, aes(y = mean, x = recommend, group = received)) +
      geom_line(aes(color = received), size = 2, alpha = 0.4) + geom_point(size = 3, aes(color = received))

    if (problem == "meta-analysis")
      plotlist[[i]] = plotlist[[i]] + ggtitle(label = paste("Study ",i))

    if (problem == "multiple outcomes")
      plotlist[[i]] = plotlist[[i]] + ggtitle(label = paste("Outcome ",i))
  }

  return(plotlist)
}


#' @title Cross Validation Error Plot for an "mp_cv" Class Object.
#'
#' @description This function plots the cross validation error as a function of the tuning parameters.
#' For penalties with 2 tuning parameters, a heat map will be plotted via the \code{image()} function
#'
#' @param mp_cv A fitted 'mp_cv' class object returned by \code{mpersonalized_cv} function
#' @param col.regions color scale. See \code{\link[Matrix]{image-methods}}
#' @param key.lab label for colorkey
#' @param ... arguments to be passed to \code{\link[lattice]{levelplot}}
#'
#' @return Nothing
#'
#' @examples
#' set.seed(123)
#' sim_dat  = simulated_dataset(n = 200, problem = "meta-analysis")
#' Xlist = sim_dat$Xlist; Ylist = sim_dat$Ylist; Trtlist = sim_dat$Trtlist
#'
#' # fit different rules with lasso penalty for this meta-analysis problem
#' mp_cvmod_diff = mpersonalized_cv(problem = "meta-analysis",
#'                                  Xlist = Xlist, Ylist = Ylist, Trtlist = Trtlist,
#'                                  penalty = "lasso", single_rule = FALSE)
#'
#' plots = plotCVE(mp_cvmod_diff)
#' set.seed(NULL)
#' @export
#' @importFrom grDevices topo.colors
plotCVE <- function(mp_cv,
                    col.regions = vcols,
                    key.lab = "CV Err",
                    ...)
{
  if (class(mp_cv) != "mp_cv") stop("object supplied must be an 'mp_cv' object as returned by 'mpersonalized_cv()'")

  dim_tune <- dim(mp_cv$cv_error)

  if (is.null(dim_tune))
  {
    plot(y = mp_cv$cv_error, type = "b", x = mp_cv$penalty_parameter_sequence,
         xlab = expression(lambda), ylab = "Cross Validation Error")
  } else
  {
    if (mp_cv$penalty == "SGL+SL")
    {
      xlab <- expression(tau[0])
    } else
    {
      xlab <- expression(lambda[2])
    }

    rn <- round(unique(mp_cvmod_diff2$penalty_parameter_sequence[,1]), 2) #gsub("[^0-9\\.]", "", rownames(mp_cv$cv_error))
    cn <- round(unique(mp_cvmod_diff2$penalty_parameter_sequence[,2]), 2) #gsub("[^0-9\\.]", "", colnames(mp_cv$cv_error))

    # topo.colors(250)
    ylab <- expression(lambda[1])
    image(as(mp_cv$cv_error, "Matrix"), col.regions = col.regions, colorkey = TRUE,
          xlab = xlab, ylab = ylab, scales = list(y = list(labels = rn, at = 1:length(rn)),
                                                  x = list(labels = cn, at = 1:length(cn),
                                                           rot = 45)),
          ylab.right = key.lab,
          sub = NULL,
          ...)
  }
}
